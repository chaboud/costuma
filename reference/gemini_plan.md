AR Costume Try-On: Execution PlanThis document outlines the step-by-step plan to build a static, client-side AR "costume" website that works on mobile devices.1. Project Goal & Core ConceptGoal: A static website that uses a phone's camera to overlay 2D or 3D "costumes" on one or more people in real-time.Core Pipeline:User (Camera): The browser's getUserMedia API captures live video.Detection (MediaPipe): The video feed is passed to the MediaPipe Pose Landmarker JavaScript library. It runs on-device and returns an array of detected poses, each with 33 landmarks (body, face, hands).Rendering (Three.js): A Three.js scene is rendered onto an HTML <canvas> element.The live video is drawn as the scene's background.For each detected person, a "costume" (a 2D plane or 3D model) is drawn on top, its position updated using the landmark data.2. Core Technology StackHTML: A single index.html file.CSS: A simple style.css for layout.JavaScript Libraries (all static/CDN):@mediapipe/tasks-vision: The core JS for MediaPipe. We'll use the PoseLandmarker task.three.js: The 3D/2D rendering library.3. Final File Structure (Static Hostable)/ (root)
├── index.html
├── style.css
├── main.js
├── assets/
│   ├── pose_landmarker_lite.task  (The ML model file, downloaded from MediaPipe)
│   ├── rick_astley.png            (Your 2D sprite with alpha)
│   └── simple_robot.glb           (A stock 3D rigged model)
4. Phase 1: Setup HTML & Camera Accessindex.html:A <video> element (to stream the camera feed, can be hidden).A <canvas> element (where Three.js will render the final output).A <div> for UI buttons (e.g., "Change Costume").<script> tags to load MediaPipe and Three.js, and our main.js.main.js (Initial Part):Use navigator.mediaDevices.getUserMedia({ video: true }) to get the camera stream.Point the <video> element's srcObject to this stream.Wait for the video to start playing (onloadeddata event).5. Phase 2: Initialize MediaPipe PoseLandmarkermain.js (Continued):Import: import { PoseLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";Load Model:Create a FilesetResolver to load the model files.Download the pose_landmarker_lite.task file from Google's CDN and put it in your assets/ folder. This is crucial for static hosting.Initialize PoseLandmarker:PoseLandmarker.createFromOptions(...)Key Settings:runningMode: 'VIDEO' (to process a continuous stream).numPoses: 3 (or more, to detect multiple people).outputSegmentationMasks: false (not needed for this).6. Phase 3: Initialize Three.js Renderermain.js (Continued):Setup: Create a THREE.Scene, THREE.WebGLRenderer (attached to your <canvas>), and an THREE.OrthographicCamera. An orthographic camera is best because it matches the 2D plane of the video feed.Video Background:Create a THREE.VideoTexture from your <video> element.Set this texture as the scene.background. This is the most efficient way to show the camera feed.7. Phase 4: The Main Loop (The "Game Loop")main.js (Continued):This is the core logic, running inside a requestAnimationFrame function called animate().Get Detections:Call poseLandmarker.detectForVideo(video, timestamp).This will return an object with a landmarks property (an array of pose arrays, one for each person).Call Render Function:Pass the results.landmarks array to a new function, e.g., renderCostumes(allPoses).Render Scene:Call renderer.render(scene, camera).Loop:Call requestAnimationFrame(animate).8. Phase 5: Implementing "Costumes" (Multi-Person)This is the renderCostumes(allPoses) function.Concept: Object PoolYou don't want to create/destroy 3D objects every frame. Create a "pool" of costume objects (e.g., 5 Rick Astleys, 5 robots) and hide them.renderCostumes(allPoses) Logic:Hide all costumes: Loop through your pool of costume objects and set costume.visible = false.Loop through detections:for (let i = 0; i < allPoses.length; i++) { ... }Get the landmarks for this person: const personLandmarks = allPoses[i];Get a costume from your pool: const costume = costumePool[i];Switch on currentCostume state: (This state is set by the UI).Case 'rick_astley' (2D Sprite):Costume: A THREE.PlaneGeometry with a MeshBasicMaterial using your rick_astley.png texture (with transparent: true).Positioning:Find the center of the shoulders: const leftShoulder = personLandmarks[11]; and const rightShoulder = personLandmarks[12];.Average their x and y positions.Convert Coords: MediaPipe gives normalized coords (0.0 to 1.0). You must convert them to Three.js screen space (e.g., -1.0 to 1.0, or pixel coordinates).Set costume.position.set(convertedX, convertedY, 0);Set costume.visible = true;Case '3d_robot' (3D Model):Costume: A loaded .glb model (THREE.SkinnedMesh).Positioning (Simple): You can just parent the whole model to the person's hip or shoulder center, just like the 2D sprite. It will "float" over them.Positioning (Advanced - Skeleton):This is much harder. You need to map MediaPipe's 33 worldLandmarks (which are in 3D meters) to the THREE.Bone objects inside your SkinnedMesh.You'd loop through bones like robot.skeleton.bones['left_shoulder'] and set its position or quaternion to match the corresponding landmark.Recommendation: Start with the simple "floating" model first. Full skeleton mapping is a big project.Case 'face_mask' (Face Tracking):Use the face landmarks (e.g., personLandmarks[0] to personLandmarks[10]).Find the bounding box of the face.Position a 2D plane (like Rick Astley) over that box.9. Phase 6: Building the UIindex.html:<div id="ui-container">
    <button id="costume-btn">Change Costume</button>
</div>
main.js:let costumes = ['rick_astley', '3d_robot', 'face_mask', 'none'];
let costumeIndex = 0;
let currentCostume = costumes[costumeIndex];

document.getElementById('costume-btn').addEventListener('click', () => {
    costumeIndex = (costumeIndex + 1) % costumes.length;
    currentCostume = costumes[costumeIndex];
    // You could update button text here
});
Your renderCostumes function will automatically pick up the new currentCostume value on the next frame. A carousel at the bottom would work the same way, just with more buttons that directly set currentCostume = 'rick_astley'.10. DeploymentPut all your files (HTML, JS, CSS, and the .task and .png/.glb assets) into a folder.Push this folder to a GitHub repository.Go to Settings > Pages and deploy from your main branch.Generate a QR code that links to your new github.io URL.