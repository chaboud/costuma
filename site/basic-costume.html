<!DOCTYPE html>
<html>
<head>
    <title>Basic AR Costumes</title>
    <style>
        body { margin: 0; font-family: Arial; background: #000; color: #fff; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #video { position: absolute; width: 100%; height: 100%; object-fit: cover; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #controls {
            position: absolute;
            bottom: 6vh;
            left: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }
        .costume-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid #fff;
            color: #fff;
            padding: 15px 20px;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            flex: 1;
            min-width: 120px;
            font-size: 16px;
            text-align: center;
        }
        .costume-btn.active { background: #ff6b6b; }
        #status {
            position: absolute;
            top: 6vh;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .costume-btn {
                padding: 20px 15px;
                font-size: 18px;
                min-width: 100px;
            }
            #controls {
                gap: 8px;
            }
        }
        #camera-toggle {
            position: absolute;
            top: 6vh;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: 2px solid #fff;
            color: #fff;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            font-size: 14px;
            z-index: 10;
        }
        #camera-toggle:hover {
            background: rgba(255,255,255,0.3);
        }
        #debug {
            position: absolute;
            top: calc(6vh + 60px);
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 200px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>

        <div id="status">Starting...</div>
        <div id="debug">Debug info...</div>

        <!-- Camera toggle button in top right -->
        <button id="camera-toggle" onclick="toggleCamera()">Camera</button>

        <div id="controls">
            <button class="costume-btn active" onclick="setCostume('rick')">Hello!</button>
            <button class="costume-btn" onclick="setCostume('grumpy')">Grumpy Cat</button>
            <button class="costume-btn" onclick="setCostume('disaster')">Disaster Girl</button>
            <button class="costume-btn" onclick="setCostume('scream')">Candy</button>
            <button class="costume-btn" onclick="setCostume('debug')">Debug Mode</button>
        </div>
    </div>

    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@2.2.2"></script>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const debug = document.getElementById('debug');

        let net;
        let currentCostume = 'rick';
        let costumeImages = {};
        let currentDeviceId = null;
        let availableCameras = [];
        let isFrontCamera = false;

        // EMA smoothing with nearest neighbor matching
        let previousPoses = [];  // Store previous frame poses for matching
        let previousScales = new Map();  // Store scale per person
        let observedScales = [];  // Track all observed scales for rolling average
        const EMA_ALPHA_POSITION = 0.3;  // Position smoothing (20% new, 80% old)
        const EMA_ALPHA_SCALE = 0.15;    // Scale smoothing (5% new, 95% old)
        const MATCH_THRESHOLD = 200;     // Max distance (px) for matching across frames
        const MAX_OBSERVED_SCALES = 30;  // Keep last 30 scale observations

        // Create a hidden canvas for PoseNet input
        const inputCanvas = document.createElement('canvas');
        const inputCtx = inputCanvas.getContext('2d');

        async function getCameraDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');
                console.log('Available cameras:', availableCameras.length);

                // Default to rear camera on mobile, front camera on desktop
                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

                if (isMobile && availableCameras.length > 1) {
                    // On iOS, prefer facingMode over deviceId for reliability
                    if (isIOS) {
                        currentDeviceId = null; // Will use facingMode instead
                    } else {
                        // Try to find rear camera (usually has "back" or "environment" in label)
                        const rearCamera = availableCameras.find(camera =>
                            camera.label.toLowerCase().includes('back') ||
                            camera.label.toLowerCase().includes('environment') ||
                            camera.label.toLowerCase().includes('rear')
                        );
                        currentDeviceId = rearCamera ? rearCamera.deviceId : availableCameras[0].deviceId;
                    }
                } else {
                    currentDeviceId = availableCameras[0]?.deviceId;
                }
            } catch (error) {
                console.log('Error getting camera devices:', error);
            }
        }

        // Match current poses to previous poses using nearest neighbor by nose position
        function matchPoses(currentPoses) {
            if (previousPoses.length === 0) {
                previousPoses = JSON.parse(JSON.stringify(currentPoses));
                return currentPoses.map(p => ({ pose: p, matched: null }));
            }

            const matched = currentPoses.map(currentPose => {
                const currentNose = currentPose.keypoints.find(kp => kp.part === 'nose');
                if (!currentNose) return { pose: currentPose, matched: null };

                let closestPrev = null;
                let minDist = Infinity;

                previousPoses.forEach(prevPose => {
                    const prevNose = prevPose.keypoints.find(kp => kp.part === 'nose');
                    if (prevNose) {
                        const dist = Math.sqrt(
                            Math.pow(currentNose.position.x - prevNose.position.x, 2) +
                            Math.pow(currentNose.position.y - prevNose.position.y, 2)
                        );
                        if (dist < minDist && dist < MATCH_THRESHOLD) {
                            minDist = dist;
                            closestPrev = prevPose;
                        }
                    }
                });

                return { pose: currentPose, matched: closestPrev };
            });

            return matched;
        }

        // Apply EMA smoothing to positions
        function smoothPositions(pose, prevPose) {
            if (!prevPose) return pose;

            const smoothedPose = JSON.parse(JSON.stringify(pose));
            smoothedPose.keypoints = pose.keypoints.map(kp => {
                const prevKp = prevPose.keypoints.find(prev => prev.part === kp.part);
                if (prevKp) {
                    return {
                        ...kp,
                        position: {
                            x: EMA_ALPHA_POSITION * kp.position.x + (1 - EMA_ALPHA_POSITION) * prevKp.position.x,
                            y: EMA_ALPHA_POSITION * kp.position.y + (1 - EMA_ALPHA_POSITION) * prevKp.position.y
                        }
                    };
                }
                return kp;
            });
            return smoothedPose;
        }

        // Calculate max distance in eye-nose-eye triangle
        function getMaxTriangleDistance(keypoints) {
            const leftEye = keypoints.find(kp => kp.part === 'leftEye');
            const rightEye = keypoints.find(kp => kp.part === 'rightEye');
            const nose = keypoints.find(kp => kp.part === 'nose');

            if (!leftEye || !rightEye || !nose ||
                leftEye.score < 0.3 || rightEye.score < 0.3 || nose.score < 0.3) {
                return null;
            }

            const dist = (p1, p2) => Math.sqrt(
                Math.pow(p2.position.x - p1.position.x, 2) +
                Math.pow(p2.position.y - p1.position.y, 2)
            );

            const d1 = dist(leftEye, rightEye);
            const d2 = dist(leftEye, nose);
            const d3 = dist(rightEye, nose);

            return Math.max(d1, d2, d3);
        }

        // Apply EMA smoothing to scale with rolling average default
        function smoothScale(rawScale, personKey) {
            // Add to observed scales
            observedScales.push(rawScale);
            if (observedScales.length > MAX_OBSERVED_SCALES) {
                observedScales.shift();
            }

            const prevScale = previousScales.get(personKey);
            if (prevScale === undefined) {
                // Use rolling average as prior for new/re-detected faces
                const avgScale = observedScales.length > 0
                    ? observedScales.reduce((a, b) => a + b, 0) / observedScales.length
                    : rawScale;

                // Blend with rolling average on first detection
                const initialScale = EMA_ALPHA_SCALE * rawScale + (1 - EMA_ALPHA_SCALE) * avgScale;
                previousScales.set(personKey, initialScale);
                return initialScale;
            }

            const smoothedScale = EMA_ALPHA_SCALE * rawScale + (1 - EMA_ALPHA_SCALE) * prevScale;
            previousScales.set(personKey, smoothedScale);
            return smoothedScale;
        }

        function detectFrontCamera() {
            if (!currentDeviceId || availableCameras.length === 0) {
                return false;
            }

            const currentCamera = availableCameras.find(camera => camera.deviceId === currentDeviceId);
            if (!currentCamera) return false;

            const label = currentCamera.label.toLowerCase();

            // Check for front camera indicators
            const frontIndicators = ['front', 'user', 'selfie', 'facetime'];
            const backIndicators = ['back', 'rear', 'environment'];

            // If it explicitly says it's a back camera, it's not front
            if (backIndicators.some(indicator => label.includes(indicator))) {
                return false;
            }

            // If it explicitly says it's a front camera, it is front
            if (frontIndicators.some(indicator => label.includes(indicator))) {
                return true;
            }

            // On mobile, if there are multiple cameras and this is the first one, it's usually front
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile && availableCameras.length > 1) {
                return currentDeviceId === availableCameras[0].deviceId;
            }

            // Default assumption for desktop/laptop built-in cameras
            return true;
        }

        async function startCamera() {
            try {
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                let constraints;

                if (isIOS && isMobile) {
                    // Use facingMode for iOS - more reliable than deviceId
                    constraints = {
                        video: {
                            width: 640,
                            height: 480,
                            facingMode: 'environment' // Start with rear camera on iOS
                        }
                    };
                    isFrontCamera = false;
                } else {
                    // Use deviceId for other platforms
                    constraints = {
                        video: {
                            width: 640,
                            height: 480,
                            deviceId: currentDeviceId ? { exact: currentDeviceId } : undefined
                        }
                    };
                    // Detect if this is a front camera
                    isFrontCamera = detectFrontCamera();
                }

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;

                console.log(`Camera is ${isFrontCamera ? 'front' : 'back'} facing`);

                // Apply mirroring to video element for front camera
                if (isFrontCamera) {
                    video.style.transform = 'scaleX(-1)';
                } else {
                    video.style.transform = 'scaleX(1)';
                }

                return stream;
            } catch (error) {
                console.error('Camera start failed:', error);
                throw error;
            }
        }

        async function init() {
            try {
                status.textContent = "Requesting camera...";

                // Get available cameras first
                await getCameraDevices();

                // Start camera
                await startCamera();

                await new Promise(resolve => {
                    video.onloadeddata = resolve;
                });

                // Ensure video is playing
                await video.play();

                // Wait for video dimensions to be available
                while (video.videoWidth === 0 || video.videoHeight === 0) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Set canvas to match video dimensions exactly
                function resizeCanvas() {
                    // Force canvas to match video internal dimensions
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;

                    // Make canvas cover the full container (like video element does)
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.position = 'absolute';
                    canvas.style.top = '0';
                    canvas.style.left = '0';
                    canvas.style.objectFit = 'cover';

                    console.log('Video internal size:', canvas.width, 'x', canvas.height);
                    console.log('Canvas covers full container');
                }

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // Mirror canvas overlay to match video mirroring
                updateCanvasMirroring();

                // Set up input canvas for PoseNet
                inputCanvas.width = video.videoWidth;
                inputCanvas.height = video.videoHeight;

                status.textContent = "Loading pose detection...";

                // Load PoseNet with higher resolution
                net = await posenet.load({
                    architecture: 'MobileNetV1',
                    outputStride: 16,
                    inputResolution: { width: 513, height: 513 },
                    multiplier: 0.75
                });

                status.textContent = "Loading costume assets...";
                await loadCostumeAssets();

                status.textContent = "Happy Halloween!";
                detectLoop();

            } catch (error) {
                console.error('Error:', error);
                status.textContent = `Error: ${error.message}`;
            }
        }

        async function loadCostumeAssets() {
            const assets = {
                scream: './assets/Scream.png',
                rick: './assets/RickAstley.gif',
                grumpy: './assets/GrumpyCat.png',
                disaster: './assets/DisasterGirl.png'
            };

            for (const [name, url] of Object.entries(assets)) {
                try {
                    if (name === 'rick') {
                        // For GIFs, create an img element that preserves animation
                        const img = document.createElement('img');
                        img.crossOrigin = 'anonymous';
                        img.style.display = 'none';
                        document.body.appendChild(img);
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = () => {
                                console.log(`Failed to load ${name}`);
                                resolve();
                            };
                            img.src = url;
                        });
                        costumeImages[name] = img;
                        console.log(`Loaded animated ${name}: ${img.naturalWidth}x${img.naturalHeight}`);
                    } else {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = () => {
                                console.log(`Failed to load ${name}`);
                                resolve();
                            };
                            img.src = url;
                        });
                        if (img.complete && img.naturalWidth > 0) {
                            costumeImages[name] = img;
                            console.log(`Loaded ${name}: ${img.naturalWidth}x${img.naturalHeight}`);
                        }
                    }
                } catch (error) {
                    console.log(`Asset ${name} failed:`, error);
                }
            }
        }

        async function detectLoop() {
            if (!net || video.videoWidth === 0 || video.videoHeight === 0) {
                requestAnimationFrame(detectLoop);
                return;
            }

            try {
                // Draw video frame to input canvas
                inputCtx.drawImage(video, 0, 0, inputCanvas.width, inputCanvas.height);

                // Debug video state before detection
                if (Math.floor(Date.now() / 1000) % 5 === 0) {
                    console.log('Video state:', {
                        videoWidth: video.videoWidth,
                        videoHeight: video.videoHeight,
                        readyState: video.readyState,
                        currentTime: video.currentTime,
                        paused: video.paused
                    });
                    console.log('Input canvas size:', inputCanvas.width, 'x', inputCanvas.height);
                }

                const rawPoses = await net.estimateMultiplePoses(inputCanvas, {
                    flipHorizontal: false,
                    maxDetections: 5,
                    scoreThreshold: 0.3,
                    nmsRadius: 20
                });

                // Apply EMA smoothing with nearest neighbor matching
                const matchedPoses = matchPoses(rawPoses);
                const poses = matchedPoses.map(({ pose, matched }) => smoothPositions(pose, matched));

                // Store smoothed poses for next frame
                previousPoses = JSON.parse(JSON.stringify(poses));

                // Debug: Log pose information
                if (Math.floor(Date.now() / 1000) % 3 === 0 && poses.length > 0) {
                    console.log(`Found ${poses.length} people (smoothed)`);
                    console.log('First pose:', poses[0]);
                }

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Sort poses by scale (distance) - smallest (furthest) to largest (closest)
                const validPoses = poses.filter(pose => pose.score > 0.3);

                // Calculate scale for each pose for sorting using triangle distance
                const posesWithScale = validPoses.map(pose => {
                    const nose = pose.keypoints.find(kp => kp.part === 'nose');
                    const maxDist = getMaxTriangleDistance(pose.keypoints);

                    let rawScale = 1.0; // Default scale
                    if (maxDist !== null) {
                        // Triangle max distance is roughly 1.2-1.5x IOD, adjust divisor
                        rawScale = Math.max(0.5, Math.min(3.0, maxDist / 50));
                    }

                    // Apply scale smoothing
                    const personKey = nose ? `sort_${Math.round(nose.position.x / 50)}_${Math.round(nose.position.y / 50)}` : `sort_${Date.now()}`;
                    const scale = smoothScale(rawScale, personKey);

                    return { pose, scale };
                });

                // Sort by scale: smallest (furthest) first, largest (closest) last
                posesWithScale.sort((a, b) => a.scale - b.scale);

                // Draw in order: back to front
                posesWithScale.forEach(({ pose, scale }, index) => {
                    console.log(`Drawing person ${index + 1} with scale ${scale.toFixed(2)} (${scale < 1 ? 'far' : scale > 1.5 ? 'close' : 'medium'})`);
                    if (currentCostume === 'debug') {
                        drawDebugInfo(pose);
                    } else if (currentCostume !== 'none') {
                        drawCostume(pose.keypoints, currentCostume);
                    }
                });

                // Update debug text with first person's info
                if (poses.length > 0) {
                    updateDebugText(poses[0], poses.length);
                }

            } catch (error) {
                console.error('Detection error:', error);
            }

            requestAnimationFrame(detectLoop);
        }

        function drawDebugInfo(pose) {
            // Since canvas matches video dimensions, scale should be 1:1
            const scaleX = 1;
            const scaleY = 1;

            // Draw all keypoints
            pose.keypoints.forEach((keypoint, i) => {
                const x = keypoint.position.x;
                const y = keypoint.position.y;

                if (keypoint.score > 0.5) {
                    // Draw keypoint
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'red';
                    ctx.fill();

                    // Label keypoint
                    ctx.font = '12px Arial';
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeText(keypoint.part, x + 10, y);
                    ctx.fillText(keypoint.part, x + 10, y);
                }
            });

            // Draw skeleton connections
            const adjacentKeyPoints = posenet.getAdjacentKeyPoints(pose.keypoints, 0.5);
            adjacentKeyPoints.forEach((keypoints) => {
                const [from, to] = keypoints;
                const fromX = from.position.x;
                const fromY = from.position.y;
                const toX = to.position.x;
                const toY = to.position.y;

                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function drawCostume(keypoints, costumeType) {
            let targetKeypoint;
            let size = { width: 100, height: 100 };

            // Find the best available keypoint for face detection
            if (costumeType === 'scream' || costumeType === 'grumpy' || costumeType === 'disaster') {
                // Try multiple face keypoints in order of preference
                targetKeypoint = keypoints.find(kp => kp.part === 'nose' && kp.score > 0.3) ||
                                keypoints.find(kp => kp.part === 'leftEye' && kp.score > 0.3) ||
                                keypoints.find(kp => kp.part === 'rightEye' && kp.score > 0.3);

                if (!targetKeypoint) {
                    // Create face center from eyes if available
                    const leftEye = keypoints.find(kp => kp.part === 'leftEye');
                    const rightEye = keypoints.find(kp => kp.part === 'rightEye');
                    if (leftEye && rightEye && leftEye.score > 0.3 && rightEye.score > 0.3) {
                        targetKeypoint = {
                            position: {
                                x: (leftEye.position.x + rightEye.position.x) / 2,
                                y: (leftEye.position.y + rightEye.position.y) / 2
                            },
                            score: Math.min(leftEye.score, rightEye.score),
                            part: 'faceCenter'
                        };
                    }
                }

                // Get triangle distance for scaling
                const nose = keypoints.find(kp => kp.part === 'nose');
                const maxDist = getMaxTriangleDistance(keypoints);
                let rawScaleFactor = 1.0;

                if (maxDist !== null) {
                    rawScaleFactor = Math.max(0.5, Math.min(3.0, maxDist / 50));
                }

                // Apply scale smoothing
                const personKeyFace = nose ? `face_${Math.round(nose.position.x / 50)}_${Math.round(nose.position.y / 50)}` : `face_${Date.now()}`;
                let scaleFactor = smoothScale(rawScaleFactor, personKeyFace);

                // Set base sizes for different face costumes (doubled for triangle distance)
                let baseWidth, baseHeight;
                if (costumeType === 'scream' || costumeType === 'grumpy') {
                    baseWidth = 400;
                    baseHeight = 400;
                } else if (costumeType === 'disaster') {
                    baseWidth = 480;  // 1.2x larger
                    baseHeight = 480;
                }

                size = {
                    width: baseWidth * scaleFactor,
                    height: baseHeight * scaleFactor
                };
            } else if (costumeType === 'rick') {
                const nose = keypoints.find(kp => kp.part === 'nose');
                const maxDist = getMaxTriangleDistance(keypoints);

                if (maxDist !== null && nose) {
                    // Scale costume based on triangle distance
                    const rawScaleFactor = Math.max(0.5, Math.min(3.0, maxDist / 50));

                    // Apply scale smoothing
                    const personKeyRick = `rick_${Math.round(nose.position.x / 50)}_${Math.round(nose.position.y / 50)}`;
                    const scaleFactor = smoothScale(rawScaleFactor, personKeyRick);

                    const baseWidth = 800;  // 2x for triangle distance
                    const baseHeight = 500;

                    targetKeypoint = {
                        position: {
                            x: nose.position.x,
                            y: nose.position.y + maxDist  // Offset down based on face size
                        },
                        score: nose.score,
                        part: 'noseOffset'
                    };
                    size = {
                        width: baseWidth * scaleFactor,
                        height: baseHeight * scaleFactor
                    };

                    console.log(`Triangle dist: ${maxDist.toFixed(1)}, Scale factor: ${scaleFactor.toFixed(2)}, Size: ${size.width.toFixed(0)}x${size.height.toFixed(0)}`);
                }
            }

            if (targetKeypoint && targetKeypoint.score > 0.3) {
                const x = targetKeypoint.position.x - (size.width / 2);
                const y = targetKeypoint.position.y - (size.height / 2);

                console.log(`Drawing ${costumeType} at keypoint ${targetKeypoint.part}:
                    Raw pos: ${targetKeypoint.position.x.toFixed(1)}, ${targetKeypoint.position.y.toFixed(1)}
                    Final draw pos: ${x.toFixed(1)}, ${y.toFixed(1)}
                    Score: ${targetKeypoint.score.toFixed(2)}`);

                if (costumeImages[costumeType]) {
                    ctx.drawImage(costumeImages[costumeType], x, y, size.width, size.height);
                } else {
                    // Fallback: draw a colored rectangle
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(x, y, size.width, size.height);
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, size.width, size.height);
                }
            } else {
                console.log(`No valid keypoint found for ${costumeType}`);
            }
        }

        function updateDebugText(pose, totalPeople = 1) {
            const scaleX = canvas.width / video.videoWidth;
            const scaleY = canvas.height / video.videoHeight;

            // Find key keypoints for debugging
            const nose = pose.keypoints.find(kp => kp.part === 'nose');
            const leftShoulder = pose.keypoints.find(kp => kp.part === 'leftShoulder');
            const rightShoulder = pose.keypoints.find(kp => kp.part === 'rightShoulder');

            let keypointInfo = '';
            if (nose) {
                keypointInfo += `Nose: (${nose.position.x.toFixed(1)}, ${nose.position.y.toFixed(1)}) score: ${nose.score.toFixed(2)}<br>`;
            }
            if (leftShoulder) {
                keypointInfo += `L.Shoulder: (${leftShoulder.position.x.toFixed(1)}, ${leftShoulder.position.y.toFixed(1)}) score: ${leftShoulder.score.toFixed(2)}<br>`;
            }
            if (rightShoulder) {
                keypointInfo += `R.Shoulder: (${rightShoulder.position.x.toFixed(1)}, ${rightShoulder.position.y.toFixed(1)}) score: ${rightShoulder.score.toFixed(2)}<br>`;
            }

            debug.innerHTML = `
                People: ${totalPeople}<br>
                Score: ${pose.score.toFixed(2)}<br>
                Canvas: ${canvas.width}x${canvas.height}<br>
                Video: ${video.videoWidth}x${video.videoHeight}<br>
                Scale: ${scaleX.toFixed(2)}, ${scaleY.toFixed(2)}<br>
                Keypoints: ${pose.keypoints.filter(kp => kp.score > 0.5).length}/17<br>
                <br>
                ${keypointInfo}
            `;
        }

        async function toggleCamera() {
            try {
                // Stop current stream first
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                    await new Promise(resolve => setTimeout(resolve, 100)); // Small delay for iOS
                }

                // Re-enumerate devices (iOS deviceIds can change)
                await getCameraDevices();

                if (availableCameras.length <= 1) {
                    console.log('Only one camera available');
                    // Restart the same camera
                    await startCamera();
                    return;
                }

                // Use facingMode approach for iOS compatibility
                const isCurrentlyFront = isFrontCamera;

                if (isCurrentlyFront) {
                    // Switch to back camera using facingMode
                    console.log('Switching to back camera');
                    currentDeviceId = null; // Let iOS choose the best back camera
                } else {
                    // Switch to front camera using facingMode
                    console.log('Switching to front camera');
                    currentDeviceId = null; // Let iOS choose the best front camera
                }

                // Use facingMode constraint for iOS compatibility
                const constraints = {
                    video: {
                        width: 640,
                        height: 480,
                        facingMode: isCurrentlyFront ? 'environment' : 'user'
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;

                // Update front camera detection based on what we requested
                isFrontCamera = !isCurrentlyFront;
                console.log(`Camera switched to ${isFrontCamera ? 'front' : 'back'} facing`);

                // Apply mirroring
                if (isFrontCamera) {
                    video.style.transform = 'scaleX(-1)';
                } else {
                    video.style.transform = 'scaleX(1)';
                }

                // Wait for video to be ready
                await new Promise(resolve => {
                    video.onloadeddata = resolve;
                });

                // Wait for dimensions
                while (video.videoWidth === 0 || video.videoHeight === 0) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Update canvas
                inputCanvas.width = video.videoWidth;
                inputCanvas.height = video.videoHeight;

                // Update mirroring for new camera
                updateCanvasMirroring();

            } catch (error) {
                console.error('Camera toggle failed:', error);
                status.textContent = "Camera switch failed. Using previous camera.";
            }
        }

        function updateCanvasMirroring() {
            // Mirror canvas overlay to match video mirroring for front camera
            if (isFrontCamera) {
                canvas.style.transform = 'scaleX(-1)';
            } else {
                canvas.style.transform = 'scaleX(1)';
            }
        }

        function setCostume(costume) {
            currentCostume = costume;
            document.querySelectorAll('.costume-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Show/hide debug box based on mode
            const debugBox = document.getElementById('debug');
            if (costume === 'debug') {
                debugBox.style.display = 'block';
            } else {
                debugBox.style.display = 'none';
            }
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>